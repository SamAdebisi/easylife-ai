# CV Blur Detection – Model Card

## Overview

- **Task**: Binary quality control – classify whether an image is sharp (`label=1`) or blurred (`label=0`).
- **Use Case**: Quickly gate camera uploads or production-line frames before downstream CV tasks.
- **Current Status**: Baseline (Phase 2). Not production-ready without further validation on real-world data.

## Data

- **Source**: Synthetic dataset generated by `pipelines/cv_prepare_data.py`.
- **Composition**: 24 grayscale images (128×128) with geometric patterns and Gaussian noise; half are intentionally blurred with a 9×9 kernel (`σ=3`).
- **Storage**: Images under `data/raw/cv/{sharp,blurred}`; manifest labels at `data/processed/cv/labels.csv` (DVC-managed).
- **Known Gaps**: Lacks real textures, lighting variations, and compression artefacts. Replace with domain data before deployment.

## Model

- **Architecture**: Variance-of-Laplacian blur score with a learned threshold.
- **Training Script**: `cv_service/train.py` (DVC stage `cv-train`).
- **Hyperparameters**:
  - Threshold search range: min–max Laplacian variance over dataset (200 steps).
  - Blurring kernel: 9×9 Gaussian, σ=3 (data generation).
- **Artifacts**: `cv_service/artifacts/blur_model.joblib` and `metrics.json`.

## Metrics

- **Baseline Results (synthetic)**:
  - Accuracy ≈ 1.0
  - F1 Score ≈ 1.0
  - Mean Laplacian variance (sharp): ~1500
  - Mean Laplacian variance (blurred): ~100
- **Tracking**: MLflow experiment `cv_blur_detection` for training, `cv_service_inference` for live telemetry.

## Serving

- **API**: `cv_service/app/main.py` (FastAPI)
  - `GET /health`
  - `POST /predict_image` → `{label, label_name, score, confidence}`
  - `GET /metrics` exposes Prometheus counters (`cv_predictions_total`).
- **Dependency**: Requires `opencv-python-headless` for inference.

## Risks & Next Steps

1. Replace synthetic dataset with production samples; version via DVC.
2. Evaluate recall on edge cases (motion blur, defocus, low-light noise).
3. Introduce CNN/Vision Transformer baseline (PyTorch) for richer feature extraction.
4. Add shadow deployment dashboards and latency SLIs in Grafana.
5. Extend API contract with per-class confidence thresholds and optional masks.
